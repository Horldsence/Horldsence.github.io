---
import "../styles/global.css";
import { ViewTransitions } from "astro:transitions";
import ThemeToggle from "../components/ThemeToggle.astro";

interface Props {
    title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="description" content="My Retro Software Repository" />
        <meta name="viewport" content="width=device-width" />
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
        <meta name="generator" content={Astro.generator} />
        <title>{title}</title>
        <ViewTransitions />
    </head>
    <body
        class="min-h-screen flex flex-col max-w-4xl mx-auto px-4 py-8 transition-colors duration-300"
    >
        <ThemeToggle />
        <header class="mb-12 text-center relative z-10">
            <div
                id="sign-board"
                class="inline-block pixel-card bg-retro-green mb-4 transform -rotate-1 cursor-grab active:cursor-grabbing select-none touch-none"
            >
                <h1
                    class="text-4xl md:text-6xl font-bold tracking-widest uppercase text-retro-dark dark:text-retro-beige pointer-events-none"
                >
                    Soft.Ware
                </h1>
            </div>
            <p
                class="text-xl text-retro-dark-800 dark:text-retro-beige/80 mt-4 font-extrabold"
            >
                <span class="text-retro-brown-700 dark:text-retro-cream"
                    >&gt;&gt;&gt;</span
                > PERSONAL REPOSITORY <span
                    class="text-retro-brown-700 dark:text-retro-cream"
                    >&lt;&lt;&lt;</span
                >
            </p>
            <nav class="mt-6 flex justify-center gap-4">
                <a
                    href="/"
                    class="pixel-btn text-lg no-underline hover:scale-105 transition-transform text-retro-dark-800 dark:text-retro-beige"
                    >HOME</a
                >
                <a
                    href="/tags"
                    class="pixel-btn text-lg no-underline bg-retro-brown text-retro-beige hover:scale-105 transition-transform"
                    >TAGS</a
                >
            </nav>
        </header>

        <main class="flex-grow text-retro-dark-700 dark:text-retro-beige/90">
            <slot />
        </main>

        <footer
            class="mt-16 text-center text-retro-dark-600 dark:text-retro-beige/50 text-base font-bold border-t-4 border-retro-dark/40 dark:border-retro-beige/20 pt-8 transition-colors"
        >
            <p>
                Â© {new Date().getFullYear()} Peng App Repository.
            </p>
            <div class="mt-2">
                <span
                    class="inline-block w-3 h-3 bg-retro-green dark:bg-retro-cream mx-1 transition-colors"
                ></span>
                <span
                    class="inline-block w-3 h-3 bg-retro-brown dark:bg-retro-green mx-1 transition-colors"
                ></span>
                <span
                    class="inline-block w-3 h-3 bg-retro-dark-700 dark:bg-retro-beige mx-1 transition-colors"
                ></span>
            </div>
        </footer>

        <script>
            class PhysicsSystem {
                items: Set<PhysicsItem>;
                mouseX: number;
                mouseY: number;
                smoothMouseX: number;
                smoothMouseY: number;

                animationFrameId: number;
                boundMouseMove: (e: MouseEvent) => void;
                boundTouchMove: (e: TouchEvent) => void;
                boundMouseUp: () => void;
                boundTouchEnd: () => void;

                constructor() {
                    this.items = new Set();
                    this.mouseX = 0;
                    this.mouseY = 0;
                    this.smoothMouseX = 0;
                    this.smoothMouseY = 0;
                    this.animationFrameId = 0;

                    this.boundMouseMove = (e) => {
                        this.mouseX = e.clientX;
                        this.mouseY = e.clientY;
                        this.items.forEach((item) => {
                            if (item.state.isDragging)
                                item.onMove(e.clientX, e.clientY);
                        });
                    };

                    this.boundTouchMove = (e) => {
                        const t = e.touches[0];
                        this.mouseX = t.clientX;
                        this.mouseY = t.clientY;
                        this.items.forEach((item) => {
                            if (item.state.isDragging)
                                item.onMove(t.clientX, t.clientY);
                        });
                    };

                    this.boundMouseUp = () => {
                        this.items.forEach((item) => {
                            if (item.state.isDragging) item.onUp();
                        });
                    };

                    this.boundTouchEnd = () => {
                        this.items.forEach((item) => {
                            if (item.state.isDragging) item.onUp();
                        });
                    };

                    this.initGlobalEvents();
                    this.loop();
                }

                initGlobalEvents() {
                    window.addEventListener("mousemove", this.boundMouseMove);
                    window.addEventListener("touchmove", this.boundTouchMove, {
                        passive: false,
                    });
                    window.addEventListener("mouseup", this.boundMouseUp);
                    window.addEventListener("touchend", this.boundTouchEnd);
                }

                destroy() {
                    window.removeEventListener(
                        "mousemove",
                        this.boundMouseMove,
                    );
                    window.removeEventListener(
                        "touchmove",
                        this.boundTouchMove,
                    );
                    window.removeEventListener("mouseup", this.boundMouseUp);
                    window.removeEventListener("touchend", this.boundTouchEnd);
                    cancelAnimationFrame(this.animationFrameId);
                }

                register(el: HTMLElement, options: any) {
                    const item = new PhysicsItem(el, options);
                    this.items.add(item);
                    return item;
                }

                updateGlobalEffects() {
                    // Smooth mouse tracking
                    this.smoothMouseX +=
                        (this.mouseX - this.smoothMouseX) * 0.1;
                    this.smoothMouseY +=
                        (this.mouseY - this.smoothMouseY) * 0.1;

                    // Background movement
                    const cx = window.innerWidth / 2;
                    const cy = window.innerHeight / 2;
                    const bgX = (this.smoothMouseX - cx) * 0.02;
                    const bgY = (this.smoothMouseY - cy) * 0.02;

                    document.body.style.backgroundPosition = `${50 + bgX * 0.1}% ${50 + bgY * 0.1}%`;

                    const elements = document.querySelectorAll(
                        ".pixel-card, .pixel-shadow, .prose pre, .pixel-btn",
                    );

                    elements.forEach((el) => {
                        const rect = el.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;

                        const dx = centerX - this.smoothMouseX;
                        const dy = centerY - this.smoothMouseY;

                        // Enhanced shadow calculation
                        const maxShadow = 12;
                        const sensitivity = 15;

                        let sx = dx / sensitivity;
                        let sy = dy / sensitivity;

                        const len = Math.sqrt(sx * sx + sy * sy);
                        if (len > maxShadow) {
                            sx = (sx / len) * maxShadow;
                            sy = (sy / len) * maxShadow;
                        }

                        (el as HTMLElement).style.setProperty(
                            "--sx",
                            `${sx}px`,
                        );
                        (el as HTMLElement).style.setProperty(
                            "--sy",
                            `${sy}px`,
                        );
                    });
                }

                loop() {
                    this.updateGlobalEffects();
                    this.items.forEach((item) =>
                        item.update(this.smoothMouseX, this.smoothMouseY),
                    );
                    this.animationFrameId = requestAnimationFrame(() =>
                        this.loop(),
                    );
                }
            }

            class PhysicsItem {
                el: HTMLElement;
                options: any;
                state: any;

                constructor(el: HTMLElement, options: any) {
                    this.el = el;
                    this.options = Object.assign(
                        {
                            canDetach: false,
                            snapDistance: 100,
                            gravity: 0.6,
                            friction: 0.94,
                            spring: 0.05, // Softer spring for calm return
                            damping: 0.82, // Adjusted damping
                            baseAngle: 0,
                        },
                        options,
                    );

                    this.state = {
                        x: 0,
                        y: 0,
                        angle: this.options.baseAngle,
                        vx: 0,
                        vy: 0,
                        vAngle: 0,
                        isDragging: false,
                        isHanging: true,
                        dragOffsetX: 0,
                        dragOffsetY: 0,
                        hasDragged: false,
                        scale: 1,
                        targetScale: 1,
                        parallaxX: 0,
                        parallaxY: 0,
                    };

                    // Initialize styles
                    this.el.style.transformOrigin = "50% 50%";
                    this.el.style.cursor = "grab";
                    this.el.style.userSelect = "none";
                    this.el.style.touchAction = "none";
                    this.el.style.willChange = "transform";

                    this.initEvents();
                }

                initEvents() {
                    const startDrag = (clientX: number, clientY: number) => {
                        this.state.isDragging = true;
                        this.state.isHanging = false;
                        this.state.hasDragged = false;
                        this.state.dragOffsetX = clientX - this.state.x;
                        this.state.dragOffsetY = clientY - this.state.y;
                        this.state.targetScale = 0.98; // Subtle press effect
                        this.el.style.cursor = "grabbing";
                        this.el.style.zIndex = "50"; // Bring to front
                    };

                    this.el.addEventListener("mousedown", (e) =>
                        startDrag(e.clientX, e.clientY),
                    );
                    this.el.addEventListener(
                        "touchstart",
                        (e) =>
                            startDrag(
                                e.touches[0].clientX,
                                e.touches[0].clientY,
                            ),
                        { passive: false },
                    );

                    // Prevent click if dragged
                    this.el.addEventListener(
                        "click",
                        (e) => {
                            if (this.state.hasDragged) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        },
                        { capture: true },
                    );

                    // Hover disturbance
                    this.el.addEventListener("mouseenter", () => {
                        if (this.state.isHanging && !this.state.isDragging) {
                            // Very subtle lift
                            this.state.targetScale = 1.01;
                        }
                    });

                    this.el.addEventListener("mouseleave", () => {
                        if (!this.state.isDragging) {
                            this.state.targetScale = 1;
                        }
                    });
                }

                onMove(clientX: number, clientY: number) {
                    const dx = clientX - this.state.dragOffsetX - this.state.x;
                    const dy = clientY - this.state.dragOffsetY - this.state.y;

                    // Threshold for "dragged" state to prevent blocking simple clicks
                    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
                        this.state.hasDragged = true;
                    }

                    this.state.x = clientX - this.state.dragOffsetX;
                    this.state.y = clientY - this.state.dragOffsetY;
                }

                onUp() {
                    this.state.isDragging = false;
                    this.state.targetScale = 1;
                    this.el.style.cursor = "grab";
                    this.el.style.zIndex = "";

                    const dist = Math.sqrt(
                        this.state.x * this.state.x +
                            this.state.y * this.state.y,
                    );

                    if (
                        !this.options.canDetach ||
                        dist < this.options.snapDistance
                    ) {
                        this.state.isHanging = true;
                    } else {
                        // Throw
                        this.state.vAngle = this.state.vx * 0.5;
                    }
                }

                update(mouseX: number, mouseY: number) {
                    // Scale animation
                    this.state.scale +=
                        (this.state.targetScale - this.state.scale) * 0.15;

                    if (this.state.isDragging) {
                        if (this.state.lastX !== undefined) {
                            this.state.vx =
                                (this.state.x - this.state.lastX) * 0.8; // Smooth velocity
                            this.state.vy =
                                (this.state.y - this.state.lastY) * 0.8;
                        }
                        this.state.lastX = this.state.x;
                        this.state.lastY = this.state.y;

                        // Tilt while dragging
                        const targetAngle = this.state.vx * 0.8; // Reduced tilt
                        this.state.angle +=
                            (targetAngle - this.state.angle) * 0.15;
                    } else {
                        this.state.lastX = this.state.x;
                        this.state.lastY = this.state.y;

                        if (this.state.isHanging) {
                            // Spring to 0,0 (No parallax)
                            const targetX = 0;
                            const targetY = 0;

                            // Spring to target
                            const ax =
                                (targetX - this.state.x) * this.options.spring;
                            const ay =
                                (targetY - this.state.y) * this.options.spring;

                            this.state.vx += ax;
                            this.state.vy += ay;
                            this.state.vx *= this.options.damping;
                            this.state.vy *= this.options.damping;

                            this.state.x += this.state.vx;
                            this.state.y += this.state.vy;

                            // Angular spring to baseAngle
                            this.state.vAngle +=
                                (this.options.baseAngle - this.state.angle) *
                                0.08;
                            this.state.vAngle *= 0.85;
                            this.state.angle += this.state.vAngle;
                        } else {
                            // Free fall
                            this.state.vy += this.options.gravity;
                            this.state.vx *= this.options.friction;
                            this.state.vy *= this.options.friction;

                            this.state.x += this.state.vx;
                            this.state.y += this.state.vy;
                            this.state.angle += this.state.vx * 0.5;

                            // Floor collision
                            const floorDist =
                                window.innerHeight -
                                100 -
                                (this.el.getBoundingClientRect().top -
                                    this.state.y);

                            if (this.state.y > floorDist) {
                                this.state.y = floorDist;
                                this.state.vy *= -0.5;
                                this.state.vx *= 0.8;
                                this.state.vAngle *= 0.8;
                            }
                        }
                    }

                    this.el.style.transform = `translate3d(${this.state.x}px, ${this.state.y}px, 0) rotate(${this.state.angle}deg) scale(${this.state.scale})`;
                }
            }

            let globalPhysicsSystem: PhysicsSystem | null = null;

            document.addEventListener("astro:page-load", () => {
                if (globalPhysicsSystem) {
                    globalPhysicsSystem.destroy();
                }
                const system = new PhysicsSystem();
                globalPhysicsSystem = system;

                // Register Sign
                const sign = document.getElementById("sign-board");
                if (sign) {
                    system.register(sign, {
                        canDetach: true,
                        baseAngle: -1,
                        snapDistance: 150,
                    });
                }

                // Register Cards and Buttons
                const interactables = document.querySelectorAll(
                    ".pixel-card, .pixel-btn",
                );
                interactables.forEach((el) => {
                    // Don't register the sign again if it has pixel-card class
                    if (el.id === "sign-board") return;

                    system.register(el as HTMLElement, {
                        canDetach: false, // Keep UI usable
                        spring: 0.15, // Stiffer spring for UI elements
                        damping: 0.7,
                        baseAngle: 0,
                    });
                });
            });
        </script>
    </body>
</html>
