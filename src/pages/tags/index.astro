---
import Layout from "../../layouts/Layout.astro";
import Card from "../../components/Card.astro";
import { getCollection } from "astro:content";

const software = await getCollection("software");
const allTags = [
    ...new Set(software.map((item: any) => item.data.tags).flat()),
].sort();
---

<Layout title="Tags Filter | Software Repository">
    <div class="mb-8">
        <a
            href="/"
            class="inline-block mb-6 text-retro-dark dark:text-retro-beige hover:text-retro-green dark:hover:text-retro-cream font-bold transition-colors"
        >
            &lt; BACK_TO_ROOT
        </a>
        <h1 class="text-4xl font-bold mb-8 uppercase tracking-widest">
            <span
                class="bg-retro-dark text-retro-beige px-2 dark:bg-retro-beige dark:text-retro-dark transition-colors"
                >Tag_Filter</span
            >
        </h1>

        <div class="mb-8">
            <p
                class="mb-4 text-base text-retro-dark dark:text-retro-beige/70 font-extrabold"
            >
                SELECT_TAGS_TO_FILTER:
            </p>
            <div class="flex flex-wrap gap-4" id="tag-container">
                {
                    allTags.map((tag) => (
                        <button
                            data-tag={tag}
                            class="tag-btn pixel-btn text-lg uppercase tracking-wider border-none cursor-pointer opacity-60 hover:opacity-100 transition-opacity"
                        >
                            {tag}
                        </button>
                    ))
                }
            </div>
        </div>

        <div
            class="mb-4 text-right text-base font-extrabold text-retro-dark dark:text-retro-beige/70"
        >
            FOUND: <span id="count-display">{software.length}</span> ITEMS
        </div>

        <div id="software-grid" class="grid grid-cols-1 md:grid-cols-2 gap-8">
            {
                software.map((item: any) => (
                    <div
                        class="software-item"
                        data-tags={JSON.stringify(item.data.tags)}
                    >
                        <Card
                            href={`/software/${item.slug}`}
                            title={item.data.title}
                            description={item.data.description}
                            icon={item.data.icon}
                            tags={item.data.tags}
                            rating={item.data.rating}
                            slug={item.slug}
                        />
                    </div>
                ))
            }
        </div>

        <div id="no-results" class="hidden text-center py-20 pixel-card">
            <p class="text-2xl">NO_MATCHES_FOUND</p>
            <p class="mt-2">Try selecting fewer tags...</p>
        </div>
    </div>

    <script>
        const tagBtns = Array.from(
            document.querySelectorAll<HTMLButtonElement>(".tag-btn"),
        );
        const items = Array.from(
            document.querySelectorAll<HTMLElement>(".software-item"),
        );
        const countDisplay = document.getElementById("count-display");
        const noResults = document.getElementById("no-results");

        let selectedTags = new Set();

        // Check URL params for initial tags
        const urlParams = new URLSearchParams(window.location.search);
        const initialTags = urlParams.get("tags");
        if (initialTags) {
            initialTags.split(",").forEach((tag) => selectedTags.add(tag));
        }

        tagBtns.forEach((btn) => {
            btn.addEventListener("click", () => {
                const tag = btn.getAttribute("data-tag");
                if (selectedTags.has(tag)) {
                    selectedTags.delete(tag);
                } else {
                    selectedTags.add(tag);
                }
                updateUI();
                updateURL();
            });
        });

        function updateUI() {
            // Update buttons
            tagBtns.forEach((btn) => {
                const tag = btn.getAttribute("data-tag");
                const isSelected = selectedTags.has(tag);
                btn.setAttribute("aria-pressed", isSelected ? "true" : "false");
                btn.dataset.active = isSelected ? "true" : "false";
                btn.classList.toggle("tag-selected", isSelected);
                btn.classList.toggle("opacity-60", !isSelected);
            });

            const grid = document.getElementById("software-grid");
            if (!grid) return;

            // Ensure grid is relative for absolute positioning of exiting items
            grid.style.position = "relative";

            // 1. Capture positions of items that will remain visible (FLIP - First)
            const visibleItemsBefore = new Map();
            items.forEach((item) => {
                // We only care about items that are currently part of the layout flow
                if (
                    !item.classList.contains("hidden") &&
                    !item.classList.contains("exiting")
                ) {
                    const rect = item.getBoundingClientRect();
                    visibleItemsBefore.set(item, rect);
                }
            });

            // 2. Apply visibility changes
            let visibleCount = 0;

            items.forEach((item) => {
                const itemTags = JSON.parse(
                    item.getAttribute("data-tags") || "[]",
                );
                // AND logic: Item must have ALL selected tags
                const shouldBeVisible = Array.from(selectedTags).every((t) =>
                    itemTags.includes(t),
                );

                if (shouldBeVisible) {
                    visibleCount++;

                    // If it was hidden or exiting, show it
                    if (
                        item.classList.contains("hidden") ||
                        item.classList.contains("exiting")
                    ) {
                        item.classList.remove("hidden");
                        item.classList.remove("exiting");

                        // Reset styles from absolute positioning if it was exiting
                        item.style.position = "";
                        item.style.left = "";
                        item.style.top = "";
                        item.style.width = "";
                        item.style.height = "";
                        item.style.zIndex = "";

                        item.classList.remove("animate-scale-out");
                        item.classList.add("animate-pop-in");
                    }
                } else {
                    // Should be hidden
                    // Only animate out if it's not already hidden or exiting
                    if (
                        !item.classList.contains("hidden") &&
                        !item.classList.contains("exiting")
                    ) {
                        // Start exit animation
                        const rect = item.getBoundingClientRect();
                        const gridRect = grid.getBoundingClientRect();

                        // Lock position to take it out of flow immediately
                        item.style.width = `${rect.width}px`;
                        item.style.height = `${rect.height}px`;
                        item.style.left = `${rect.left - gridRect.left}px`;
                        item.style.top = `${rect.top - gridRect.top}px`;
                        item.style.position = "absolute";
                        item.style.zIndex = "0";

                        item.classList.add("exiting");
                        item.classList.add("animate-scale-out");
                        item.classList.remove("animate-pop-in");

                        item.addEventListener(
                            "animationend",
                            () => {
                                if (item.classList.contains("exiting")) {
                                    item.classList.add("hidden");
                                    item.classList.remove("exiting");
                                    item.classList.remove("animate-scale-out");
                                    // Clean up inline styles
                                    item.style.position = "";
                                    item.style.left = "";
                                    item.style.top = "";
                                    item.style.width = "";
                                    item.style.height = "";
                                    item.style.zIndex = "";
                                }
                            },
                            { once: true },
                        );
                    }
                }
            });

            // 3. FLIP Animation for remaining items (Last, Invert, Play)
            items.forEach((item) => {
                if (
                    visibleItemsBefore.has(item) &&
                    !item.classList.contains("hidden") &&
                    !item.classList.contains("exiting")
                ) {
                    const oldRect = visibleItemsBefore.get(item);
                    const newRect = item.getBoundingClientRect();

                    const deltaX = oldRect.left - newRect.left;
                    const deltaY = oldRect.top - newRect.top;

                    if (deltaX !== 0 || deltaY !== 0) {
                        // Invert
                        item.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        item.style.transition = "none";

                        // Force reflow
                        void item.offsetHeight;

                        // Play
                        item.style.transition =
                            "transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)";
                        item.style.transform = "";

                        // Clean up transition after it's done
                        item.addEventListener(
                            "transitionend",
                            () => {
                                item.style.transition = "";
                            },
                            { once: true },
                        );
                    }
                }
            });

            // Update count and no results message
            if (countDisplay) {
                countDisplay.textContent = visibleCount.toString();
            }
            if (visibleCount === 0) {
                if (noResults?.classList.contains("hidden")) {
                    noResults.classList.remove("hidden");
                    noResults.classList.add("animate-pop-in");
                }
            } else {
                noResults?.classList.add("hidden");
                noResults?.classList.remove("animate-pop-in");
            }
        }

        function updateURL() {
            const url = new URL(window.location.href);
            if (selectedTags.size > 0) {
                url.searchParams.set(
                    "tags",
                    Array.from(selectedTags).join(","),
                );
            } else {
                url.searchParams.delete("tags");
            }
            window.history.replaceState({}, "", url);
        }

        // Initialize UI state on first load
        updateUI();
    </script>

    <style>
        :global(.tag-btn[data-active="true"]) {
            outline: 2px solid #283618;
            box-shadow:
                -3px 0 0 0 #283618,
                3px 0 0 0 #283618,
                0 -3px 0 0 #283618,
                0 3px 0 0 #283618;
            transform: translate(-1px, -1px);
        }

        :global(html.dark .tag-btn[data-active="true"]) {
            outline-color: #fefae0;
            box-shadow:
                -3px 0 0 0 #fefae0,
                3px 0 0 0 #fefae0,
                0 -3px 0 0 #fefae0,
                0 3px 0 0 #fefae0;
        }
    </style>
</Layout>
